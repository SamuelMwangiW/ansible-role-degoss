#!/usr/bin/env bash

: ${LOGGING_LEVEL="info"}

function .debug () {
  if .is-log-allowed debug ; then
    .log debug $@
  fi
}

function .info() {
  if .is-log-allowed info ; then
    .log info $@
  fi
}

function .warn() {
  if .is-log-allowed warn ; then
    .log warn $@
  fi
}

function .error() {
  if .is-log-allowed error ; then
    .log error $@
  fi
}

function .get-log-level() {
  .to-lower "${LOGGING_LEVEL}"
}

function .is-log-allowed() {
  declare -A allowed_logging_levels
  allowed_logging_levels=(
    ["trace"]="trace|debug|info|warn|error"
    ["debug"]="debug|info|warn|error"
    ["info"]="info|warn|error"
    ["warn"]="warn|error"
    ["error"]="error"
    ["silent"]=""
  )

  local request_level="$(.to-lower $1)"
  local current_level="$(.get-log-level)"
  local allowed_levels=${allowed_logging_levels[$current_level]}

  if echo "$allowed_levels" | grep -qP "\b$request_level\b" ; then
    return 0
  else
    return 1
  fi
}

function .log() {
  local level="$(.to-upper ${1:-SHRUG})"
  local timestamp="$(date -u +"%Y-%m-%d %H:%M:%S%z")"
  local color=""

  shift # due to level

  case $level in
    DEBUG)
      color=green
      ;;
    INFO)
      color=blue
      ;;
    WARN)
      color=yellow
      ;;
    ERROR)
      color=red
      ;;
    *)
      # ie no color
      color=black
      ;;
  esac

  # emit logging statement
  .term.set-fg $color && \
    printf '%-24s [%-5s] ' "${timestamp}" "${level}" && \
    echo "$@" && \
    .term.reset
}

function .to-lower() {
  echo $@ | awk '{print tolower($0);}'
}

function .to-upper() {
  echo $@ | awk '{print toupper($0);}'
}

function .term.bold() {
  tput bold
}

function .term.reset() {
  tput sgr0
}

function .term.is() {
  local rc=$(test -t 1 ; echo $?)
  return $rc
}

function .term.set-fg() {
  declare -a color_ids
  color_ids=(
    ["black"]="0"
    ["red"]="1"
    ["green"]="2"
    ["yellow"]="3"
    ["blue"]="4"
    ["magenta"]="5"
    ["cyan"]="6"
    ["white"]="7"
  )

  local color="$1"
  local color_id="$1"

  if ! echo ${color} | grep -qP '\d+' ; then
    # if it's not already an id, look it up
    color_id="${color_ids[$color_id]}"
  fi

  if .term.is ; then
    tput setaf ${color_id}
  fi
}

function .main() {
  local commands=("$@")
  local rc_file="/tmp/playbook.rc"
  local log_file="/tmp/playbook.log"
  # we allow failures to happen so as to record the return code
  set +e

  # run the failing playbook, recording its return value and output
  ( tests/runc exec ${commands[@]} ; echo $? > $rc_file) | tee $log_file

  # henceforth, die if an error is encountered
  set -e

  # collect the return code and the output
  local return_code=$(cat $rc_file)
  local failed_count=$(grep -oP '(?<=Failed:\s)(\d+)' $log_file | tail -n 1)

  if [ $return_code -eq 0 ] ; then
    .error "The playbook was expected to fail and did not."
    return 1
  elif [ -z "$failed_count" ] || [ $failed_count -lt 1 ]; then
    .error "The playbook was expected to have failed at least one Goss test. (failed: ${failed_count:-undefined})" >&2
    return 1
  else
    .info "Success, the playbook failed with ${failed_count} failure(s) and a return code of ${return_code}."
    return 0
  fi
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  set -e
  .main "$@"
fi
